# Тренировочное задание по программированию: StackVector
## Условие
В блоке про модель памяти мы говорили, что динамическая память нужна для хранения тех объектов, которые должны жить дольше, чем создавшая их функция. Кроме того мы говорили, что можно создать такой вектор, который не использует память из кучи, а хранит все свои объекты на стеке. В этой задаче вам предстоит это сделать. Вы совсем недавно познакомились с контейнером array, который хранит все свои данные на стеке. Реализуйте интерфейс вектора поверх него. Более формально, реализуйте шаблон класса template <typename T, size_t N> StackVector<T, N>, где T — тип элемента вектора, а N — его максимальная вместимость.
* Метод Capacity должен возвращать вместимость вектора, то есть количество объектов, которое в него в принципе может поместиться.
* Метод Size должен возвращать текущее количество объектов в векторе
* Конструктор принимает размер вектора (по аналогии со стандартным вектором). Если аргумент конструктора оказался больше вместимости вектора, конструктор должен выбрасывать исключение invalid_argument
* Методы begin/end должны возвращать итераторы на начало и текущий конец вектора; их тип не указан, вы должны выбрать его самостоятельно
* Метод PushBack добавляет новый элемент в конец вектора. Если текущий размер вектора равен его вместимости, метод PushBack должен выбрасывать стандартное исключение overflow_error
* Метод PopBack уменьшает размер вектора на один и возвращает элемент вектора, который был последним. Если вектор пуст, метод PopBack должен выбрасывать стандартное исключение underflow_error
